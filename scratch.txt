
    [ , ]
    when you see <]>, scan backwards and collect everything until we find <[>
    if, when we find a <[>, the token to the left of it is a symbol, then we have scanned across an array indexer
        array[<expression>]

    else, then we have scanned across an array literal
        ... [ <expression> , <expression> , ... ]

    ( , )
    when you see <)>, scan backwards and collect everything until we find <(>
    if, when we find a <(>, the token to left of it is a symbol, then we have scanned across a function call or definition
        if what we scanned across is a bunch of expressions, then it's a function call...
            func(<expression>, <expression>, ...)
            func();
            func().
            func() -

        else if what we scanned is a bunch of definitions, then it's a function definition
            func(<definition>, <definition>)
            func() { ... }

    else, then we have scanned across a group of sub-expressions
        (4 + 2 - x) * 5



  Some notes on grouping operators/punctuators as in [], {}, ()
  because they are weird...

  One way to deal with them is to treat openers as sentinels, and then treat the closers as a unary postfix
  operator, where their 'single' child is:

       )   -   an expression (used for grouping/precdence),
               a comma separated list of expressions (function call),
               a comma separated list of definitions (function arg definition)

       }   -   a comma separated list of tuples (dict literal), a group of statements or expressions (closure)
       ]   -   a comma separated list of expressions (array literal), a group of expressions (indexer)

       ? more bullshit ?


            if      ____
          /   \         \
         /      \        \
    condition  tihng    else

    obj := { bar: 0, baz: 2 };
    obj := {};
    obj.bar = 0;
    obj.baz = 0;

    foo(bar: Int, baz: Int): Int, Int { ... }

    array: Int[] = foo(...);
    x, y: Int = foo(...);

    x: Int, y: Int

    foo(array);

    foo(obj.bar, obj.baz);

    foo(obj);

        foo(): String, Double

        x, y = foo();

        x = foo()[0];
        y = foo()[1];



       code (string) ---> | ................ | ---> code again (compiler)
       code (string) ---> | ................ | ---> nothing (but the intermediate stages produce some mutation of the state of something else) (interpreter)

